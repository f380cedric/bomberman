\newpage
\section{Designs Patterns}
Alors qu'initialement nous comptions adopter le modèle MVC, nous avons connu quelques 
soucis lors de sa mise en place. Du à notre manque d'expérience dans le monde de la  
programmation orientée objet, nous n'avons pas réussi à scinder de façon complète 
le contrôleur de le vue. Ne ne sommes pas parvenu à dissocier la gestion des
entrées utilisateurs de l'actualisation de l'affichage produit par ces mêmes actions.
Étant quelque peu en manque de connaissance et surtout en manque de temps, nous avons
préféré trouver une solution alternative, à savoir le regroupement de ces deux entités.

\subsection{Model \& ViewController}
Le design pattern que nous avons choisi pour notre projet est le modèle-vue-contrôleur, 
MVC en abrégé. L'intérêt de l'utilisation de ce patron est de séparer notre programme 
en trois parties différentes, ayant chacune un objectif particulier :
\begin{enumerate}
\item Un modèle
\item Une vue-contrôleur
\end{enumerate}\ \\
Le \textit{modèle} se charge de la gestion des données : les objets qui le constituent sont 
chargés de leurs traitements. Après avoir mis à jour les données, le modèle informera la  
vue-contrôleur de se mettre à jour. La \textit{vue-contrôleur} est chargée d'un double 
rôle. Son premier consiste en la mise à jour de l'interface graphique sur demande du modèle.
Le deuxième rôle qu'elle tient est de vérifier la validité des données entrées par l'utilisateur
et des les transmettre au modèle si celles-ci s'avèrent valides. La seule différence entre 
ce modèle et le modèle MVC est que, pour des raisons purement techniques, nous n'avons pas été en 
mesurer de séparer la vue du contrôleur en deux classes distinctes.\\

La motivation à utiliser ce design pattern découle de la séparation claire entre 
l'interface graphique gérée par la vue et le traitement des données par le modèle. 
Cette séparation rend le développement de l'interface graphique plus simple que si
celle-ci devait être "éparpillée" dans les différentes parties du code. La 
séparation des tâches est un avantage de poids pour ce projet réalisé en équipe : la
répartition des travaux ainsi que la maintenance peut se faire de façon naturelle. De 
plus, "découper" un code en plusieurs parties diminue grandement la complexité générale 
au niveau de la conception.


	\subsection{Implémentation du MVC à notre projet}
		\subsubsection{ViewController}
		Notre \textit{ViewController} se compose de deux classes : 
		\begin{multicols}{2}
        \begin{enumerate}
            \item \texttt{GameWindow}
            \item \texttt{GamePanel}
        \end{enumerate}
	    \end{multicols}
	    La classe \texttt{GameWindow} hérite de la classe \texttt{GameJFrame}. C'est elle 
	    qui se charge d'afficher une fenêtre à une taille pré configurée. Le contenu
	    de cette fenêtre est géré par la classe \texttt{GamePanel} qui hérite de la 
	    classe \texttt{JPanel}. Celle-ci récupère les modifications effectuées par le 
	    modèle après que celui-ci lui ait informé de se mettre à jour pour ensuite 
	    les afficher mais cette classe se charge également de récupérer les entrées 
	    utilisateurs pour les transmettre
	    au modèle.
	    
		
		\begin{figure}[H]
        \centering
            \subfigure [View]{\includegraphics[scale=0.17]{ch1/View}}
        \quad
            \subfigure [Controller]{\includegraphics[scale=0.17]{ch1/Controller}}
            \caption {Diagramme des classes : View/Controller \textbf{A CHANGER}}
        \end{figure}		
            
        
        \subsubsection{Model}
        Notre \textit{model} se compose de deux interfaces :
  		\begin{multicols}{2}
        \begin{enumerate}
            \item \texttt{IPlayer}
            \item \texttt{Explosion}
        \end{enumerate}
	    \end{multicols}
	    et de dix classes dont deux classes mère ($\bullet$) où la première est 
	    abstraite. Les implémentations d'interfaces sont représentées par $\rightarrow$, 
	    les classes filles par une sous-liste (-) et l'implémentation d'interface entre
        une classe concrète et une interface par $\twoheadrightarrow$\footnote{Pour 
        plus de clarté, consultez la \autoref{fig:DiagModel}} :
	    \begin{multicols}{2}
        \begin{itemize}

            \item \texttt{Element}
            \begin{itemize}
            \item[$\rightarrow$] \texttt{Explosion}
				\begin{itemize}
				\item[$\twoheadrightarrow$] \texttt{NExplode}
				\item[$\twoheadrightarrow$] \texttt{PExplode}
				\item[$\twoheadrightarrow$]	 \texttt{EBomb}			
				\end{itemize}				            
            
            
	        \item \texttt{Player}
	        \begin{itemize}
	        \item[$\rightarrow$]	 \texttt{IPlayer}	
	        \end{itemize}
            \item \texttt{Bomb}
            \item \texttt{Block}
            \item \texttt{Bedrock}
            \item \texttt{Bonus}
            \end{itemize}
            \item \texttt{Board}
        
        \end{itemize}
        \end{multicols}
        
        La classe avec laquelle notre contrôleur communique est la classe 
        \texttt{Board}. La classe board crée une matrice remplie d'éléments 
        de type \texttt{Element} : joueurs, différents blocs, bombes, etc. 
        Lorsque l'utilisateur demande d'effectuer un déplacement, celui-ci 
        est renseigné à cette classe via le contr\^oleur pour finalement 
        modifier les attributs de positions du joueur. La matrice remise à 
        jour, un message sera envoyé à la vue afin de remettre à jour l'
        interface graphique.\\
        
        Les différents composants de notre classe \texttt{Board} sont tous 
        de types \texttt{Element}. La classe \texttt{Element} possède cinq 
        classes filles : \texttt{Player, Bomb, Block, Bedrock, Bonus}. Le 
        nom des classes est assez explicite si ce n'est pour les deux classes 
        chargées de la gestion des blocs :
        \begin{enumerate}
        \item \texttt{Block} : une case pouvant \^etre détruite suite à l'
        explosion d'une bombe.
        \item \texttt{Bedrock} : une case ne pouvant \^etre détruite (ainsi 
        qu'une petite référence à \textit{Minecraft}).
        \end{enumerate}
        
        Afin de gérer les explosions de façon la plus efficace que possible, 
        la méthode \texttt{explode()} a été définie au sein de la classe 
        \texttt{Element}. Or, cette méthode n'a pas le même comportement pour
        un objet de la classe \texttt{Bedrock} que pour un de la classe \texttt{Bomb} 
        mais a le m\^eme pour un objet de la classe \texttt{Bonus}. 
        Afin que cette méthode puisse être utilisée de façon polymorphe et pour
        éviter les doublons de code, l'interface \texttt{Explosion} implémentée 
        à \texttt{Element} permet de définir un comportement adapté à l'objet
        concerné.\\
        
		Cependant, la classe \texttt{Player} doit posséder des attributs et 
		des méthodes que les autres classes héritant de \texttt{Element} ne 
		possèdent pas. Afin de conserver le polymorphisme, l'interface 
		\texttt{IPlayer} a été implémentée à notre classe \texttt{Player}.
        
        \begin{center}
		\includegraphics[scale=0.35]{ch1/Model}
 	 	\captionof{figure}{Diagramme les classes : Model}
 	 	\label{fig:DiagModel}
        \end{center}
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
		
	